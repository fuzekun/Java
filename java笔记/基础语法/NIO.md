



# NIO





# 0. 底层原理



## 0.0 系统调用

1. 系统调用，通过一个80软中断，让权给操作系统，然后由操作系统进行硬件的操作。

![image-20220716200034692](D:\blgs\source\imgs\image-20220716200034692.png)

## 0.1 网络连接的系统调用

```java
使用最古老的多线程进行I/0
```

1. `starce`追踪程序对内核有没有系统调用 -o 放在哪个文件中。

![image-20220716193548302](D:\blgs\source\imgs\image-20220716193548302.png)

2. grep 'step1' ./*  当前文件中含有step1的内容。
3. jps,得到2878是进程号
4. cd /proc/2878                      # 万物皆文件,查找线程的内容。
5. 含有task，进程含有的线程号。
6. cd fd , 0:表示标准输入，1：表示标准输出，2：表示错误输出

![image-20220716194231946](D:\blgs\source\imgs\image-20220716194231946.png)

7. `netstat -antp`

8. nc localhost 8090

9. man 1-8 （2）是系统调用 
10. scoket中含有example中。









## 0.2 BIO时代



![image-20220716195813083](D:\blgs\source\imgs\image-20220716195813083.png)





1.  完成功能：已经可以连接服务器了。并且来一个连接，就可以处理一个。
2. 问题：
   - 创建线程需要clone系统调用。
   - 消耗内存资源， 内存1M。
   - 来回切换线程浪费时间 

## 0.3 NIO模型

1. 实现：socket中有一个 socket_nonblocking，可以不阻塞，直接返回一个东西。可以是空字符，可以是一个字符这种。

![image-20220716201159221](D:\blgs\source\imgs\image-20220716201159221.png)



2. 问题：

不阻塞了，客户端不用开启新的线程了，使用一个线程while死循环自己监听所有的fd，如果有字符就读入进来。但是每一次循环都需要进行N次系统调用。就是需要调用accept一次。所以需要调用N次accept()

## 0.4 多路复用模型

1. 实现：使用select, 一次给他多个文件描述符。然后有东西，就通知程序，然后程序进行接收。

![image-20220716201825484](D:\blgs\source\imgs\image-20220716201825484.png)



2. 模型的问题：虽然传递的是数组，但是遍历只是放在了内核中进行。



## 0.5 epoll

1. epoll_create :创建一个区域
2. epoll_ctl(fd8, add, fd5, accept): 把文件描述符，放在fd8里面
3. epoll_wait(fd8, event)
4.  DMA方式，硬中断，回调。

![image-20220716202659251](D:\blgs\source\imgs\image-20220716202659251.png)

![image-20220716204856598](D:\blgs\source\imgs\image-20220716204856598.png)



## 0.6 总结



- 结果就是，从select的轮询方式，到了epoll的中断方式。或者说是DMA方式。



## 0.7 nginx和redis的测试

 

![image-20220716205428788](D:\blgs\source\imgs\image-20220716205428788.png)



redis轮询, nginx阻塞。

因为redis是多线程。



## 0.8 零拷贝

1. sendfile系统调用：没有经过内核空间。
2. 前提：数据不需要加工
3. randomAccecor可以直接操作缓冲区。



![image-20220716211238934](D:\blgs\source\imgs\image-20220716211238934.png)



# 1. 概述

![image-20220411095448027](D:\blgs\source\imgs\image-20220411095448027.png)

## 阻塞/非阻塞 or 同步/异步

1.  在进程通信中：阻塞和非阻塞，同步和异步是同样的概念。
2. 在IO系统调度方面，非阻塞IO系统调用和异步IO系统调用，





## 网络I/O模型



1. 阻塞与非阻塞：观察者模式，如果发生了感兴趣的事件。系统会进行一个一个系统通知告诉进程需要做什么。或者一个handler让系统执行。
2. selector进行监听各个事件，如果有事件进行系统通知。

















# 2.  Channel

# 3. Buffer

# 4. Selector

# 5. Pip 和FileLock

# 6. 零拷贝

# 7. 操作系统的I/O介绍

## 7.0 I/O软件层次结构



![image-20220511183134250](D:\blgs\source\imgs\image-20220511183134250.png)

## 7.1 I/O核心子系统



### 1. 设备独立性软件

### 2. 驱动程序

### 3. 中断处理程序

### 4. 硬件（控制器 + 硬件）

**1. 控制器的组成**

![image-20220511184337881](D:\blgs\source\imgs\image-20220511184337881-16579627490911.png)



**2. I/O控制器的功能**

- 完成cpu对设备的控制（**控制寄存器**）
- 向cpu报告设备的状态 (**状态寄存器**)
- 数据交换 (**数据寄存器**)
- 地址识别 (**对寄存器进行编码**)
- **对多个设备进行控制**

**3. I/O控制器的工作流程**



## 7.2 I/O控制方式

![image-20220511185011511](D:\blgs\source\imgs\image-20220511185011511-16579627549553.png)

### 1.  轮询

### 2. 中断

### 3. DMA

### 4. 通道



## 7.3 假脱机技术

- 起源
- 设计
  - 多进程模拟外围机
  - 磁盘模拟输入输出井
  - 输入缓冲和输出缓冲就是内存中的中转站

![image-20220511185847627](D:\blgs\source\imgs\image-20220511185847627.png)

- 实际应用 -- 共享打印机

![image-20220511190128358](D:\blgs\source\imgs\image-20220511190128358.png)

## 7.4  设备分配与回收

![image-20220511190345651](D:\blgs\source\imgs\image-20220511190345651.png)

## 7.5 缓冲区管理

![image-20220511190409936](D:\blgs\source\imgs\image-20220511190409936.png)





# 8. NIO的原理详解(涉及到计组和操作系统和网络)

