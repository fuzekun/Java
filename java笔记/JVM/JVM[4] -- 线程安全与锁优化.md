# JVM -- 线程安全与锁优化



## 0. Java的线程与协程

![image-20220510160933725](D:\blgs\source\imgs\image-20220510160933725.png)

![image-20220510160903066](D:\blgs\source\imgs\image-20220510160903066.png)

### 0.1 线程的实现方式

>  <font size=4.7>**1.操作系统中线程实现方式有三种**:</font>

- 内核支持线程(KST) (Kernel Supported Threads)
- 用户级线程ULT（User Level Thread)
- 组合方式

> <font size=4.7>**2.各自的优缺点**</font>

![image-20220331110936276](D:\blgs\source\imgs\image-20220331110936276.png)

### 0.2 协程

**什么是协程？如何使用协程？协程的核心思想是什么？有什么优缺点**

- 轻量级的线程，由于用户线程和内核线程切换需要有上下文的开销
  - 调用不同方法，进入不同的操作数栈
  - 虚拟机，栈帧的替换
  - 硬件，内存和寄存器的复制粘贴
- 优点：轻量级
- 缺点：使用麻烦，并且如果使用协同调度，可能会产生系统崩溃。
- 应用层序层面进行协程的调用。一个线程可以开出来多个协程。



### 0.3 线程的调度

1. 协同式
2. 抢占式

### 0.4 线程的状态以及转化

- 见图片

![image-20220510161158722](D:\blgs\source\imgs\image-20220510161158722.png)



## 1. Java中的线程安全





### 1.1 volatile 关键字的字节码

1. 保证**有序性**

​	1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

  2. 无法保证原子性

     - 这个是由于java中的运算符并不是原子的，也就是说不是一条指令，或者多条指令强制逐条执行。
  3. 实现的原理(lock关键字的作用)

     - 将本处理器的缓存写入内存，并且让其他处理器或内核的缓存无效化（**缓存无效，不代表计算过程的计算作废**）

     - 不允许其他执行重新排序到这条指令之前，也不允许放在其他指令之后。（锁住了芯片不让其他占用）

     - 同一个时刻，对一个变量，只有一个线程可以对其使用lock操作。
  4. 使用场景

     - 只有一个线程进行修改，或者运算结果并不依赖当前的值。（不管true or false，都对我修改成true没啥影响）。
     - 变量不需要其他的状态变量共同参与不变约束。



![image-20220510162247683](D:\blgs\source\imgs\image-20220510162247683.png)









### 1.2 线程安全描述

> <font size=4.7>**1. 先行发生原则 -- 判断线程是否安全**</font>

1. 程序次序规则：控制流按照顺序执行。
2. 管程锁定规则 : **同一个锁**的unlock发生先于后面的lock操作。**synornized规则**
3. **volatile变量规则** : 写操作发生于后面对这个变量读操作。防止指令重排。
4. 线程启动规则 : 

![image-20220525200609015](D:\blgs\source\imgs\image-20220525200609015.png)

5. 线程终止规则：

![image-20220525200625895](D:\blgs\source\imgs\image-20220525200625895.png)

6. 线程中断规则：

![image-20220525200639109](D:\blgs\source\imgs\image-20220525200639109.png)

- 就是下面代码中，x的写对于t2来说，是可读的。

```java

    static int x;
    public static void testInterruptRule() {

        Thread t2 = new Thread(()->{
            while(true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println(x);
                    break;
                }
            }
        },"t2");
        t2.start();
        new Thread(() -> {
            try{
                Thread.sleep(1);
            }catch (Exception e) {
                e.printStackTrace();
            }
            x = 10;                         // 这个写，对于t2的读可见
            t2.interrupt();
        }, "t1").start();
        System.out.println(x);
    }
```



1. 对象终结规则：
2. 传递性:







> <font size=4.7>**2. 原子性，可见性以及有序性**</font>

> <font size=4.7>**3. 线程安全的级别？**</font>

### 1.3 线程安全的实现方法

> <font size=4.7>**1. 1.5以后的原子类**</font>

> <font size=4.7>**2. synchornized**</font>

> <font size=4.7>**3. volatile**</font>

### 1.4 锁升级的过程

>  偏向锁 -> 自旋锁 -> 重量级别锁

> Q1: 为什么锁升级之后，markword中相应的字段会消失。

### 1.5 Volatile如何实现的

1. 代码层面：volatile关键字
2. 字节码层面：加上访问标志
3. JVM层面：内存屏障，告诉虚拟机**编译的时候不能指令重排**
4. hotspot层面：Lock -- 锁上了总线，**变成了串行执行**
5. 硬件层面：电信号

- lock作用的补充
  - 将本线程的工作内存写入内存   -- **写屏障**， -- write and load 操作 
  - 引起**其他cpu**线程的工作内存无效化 -- **读屏障** -- 都之前进行一次 load and read
  - **防止指令重排** -- **执行的时候不能乱序执行。**
  - **总结就是把不同多核cpu的线程变成串行执行**
- 总结来说，**lock保证了可见性，因为应用了缓存一致性协议，而JVM和lock共同保证了指令不重排序**。

### 1.6 volatile关键字的应用

1. 可见性应用：
   - 满足只有单一线程操作，或者**运算结果不依赖当前的值。bool类型的变量。**。
   - 变量不需要其他状态的变量共同参与不变约束。
2. 有序性应用：双锁检测中需要加上volatile关键字。
3. 双锁检测也满足第一条，因为是 **==null**也是一个bool类型的变量。



下面是创建对象的字节码指令:

![image-20220523101832017](D:\blgs\source\imgs\image-20220523101832017.png)

![image-20220523101529440](D:\blgs\source\imgs\image-20220523101529440.png)



1. 如果putstatic指令，经过指令重排，放在了dup之前，那么getstatic指令就会获得没有调用初始化方法的对象，就会导致程序出问题。





### 1.7 long 和 double的特殊规则



### 1.8 一些问题

- 摩尔定律与Amdahl定律
  - 摩尔定律说，芯片上所承载的晶体管的数量18个月变回翻一番，侧重于描述晶体管的数量与运行效率之间的发展关系。
  - Amadahl滴定律通过系统并行化和串行化的比重来描述多处理器系统能够获得的运算加速能力。

- 乱序发射，乱序执行是组成远离中哪一张的内容？

- volitile关键字的局限与关键字的使用途经。

  - 保证**有序性**

    - 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；**内存屏障**

    - 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

  - 无法保证原子性，这个是由于java中的运算符并不是原子的，也就是说不是一条指令，或者多条指令强制逐条执行。

- volitile 实现的原理(lock关键字的作用)

  - 将本处理器的缓存写入内存，并且让其他处理器或内核的缓存无效化，**保证了可见性**（**缓存无效，不代表计算过程的计算作废**）


  - **锁住一条指令的意义在于**：不允许其他执行重新排序到这条指令之前，也不允许放在其他指令之后，从而禁止了指令的重新排序。

- volatiel使用场景

  - 只有一个线程进行修改，或者运算结果并不依赖当前的值。（不管true or false，都对我修改成true没啥影响）。


  - 变量不需要其他的状态变量共同参与不变约束。

- 为什么每个线程要有自己的工作内存

  - 因为堆是线程共享的，很多线程同时向堆申请内存就难免会有冲突，所以为了安全申请内存会有锁的机制，而有锁机制就无法避免的会降低性能。

  - 有线程本地缓存的话，创建对象优先分配到线程本地缓存，这样就不需要向堆内存去申请对象空间，而且在线程空间里申请的内存会随着方法的出栈而释放出来，不需要GC处理。

## 2. Java内存模型



**主内存直接对应于物理硬件的内存，工作内存优先存储于寄存器和高速缓存，因为程序运行时主要访问读写的是工作内存。**

![主内存与工作内存还有线程](D:\blgs\source\imgs\SouthEast-16532747712653.jpeg)



就是因为工作内存比较快，所以才进行的上述的逻辑划分。

![img](D:\blgs\source\imgs\SouthEast.jpeg)

![这里写图片描述](D:\blgs\source\imgs\SouthEast.jpeg)



- load和store 进行**总线权**的获取或者是放入到某一级别的**缓存**中。
- read和write从**总线或者缓存**中读取数据



在思考一个问题：

- 线程是运行的最小单位，进程是分配资源的最小单位。Java中的栈空间是线程私有的，算不算线程的资源？
- 进程和线程的区别到底在哪？

>进程（Process）是**计算机中的程序关于某数据集合上的一次运行活动**，是系统进行资源分配和调度的基本单位，是[操作系统](https://baike.baidu.com/item/操作系统)结构的基础。在早期面向进程设计的计算机结构中，**进程是程序的基本执行实体**；在当代面向线程设计的计算机结构中，进程是**线程的容器**。程序是指令、数据及其组织形式的描述，进程是程序的实体。 [1] 



三个角度：

1. 精确定义 -- 求同求异
2. 精确类比 
3. 归纳和抽象



进程： QQ, 微信

线程：QQ中可以同时开多个对话框。



进程：线程的容器

线程：进程的执行的实体，是程序在某数据集合上的一次运行活动。











### 2.1 缓存一致性协议



- [缓存一致性协议](https://blog.csdn.net/yaoyaobird11/article/details/119733625)



1. 如果是**单核的MISE协议就没有用武之地了**。因为线程都是并发执行，执行完成之后，直接放回主存就行了。不存在一个读，一个读的时候，另一个给修改了的问题。只有并行执行的时候才会出现这种问题。这个时候volatile就只是起到了防止指令重排序的功能。
2. 如果是多核的，就算没有指令重排序，也需要volatile保证可见性。
3. **MESI协议最多只是保证了对于一个变量，在多个核上的读写顺序，对于多个变量而言是没有任何保证的**
4. 数据依赖和控制依赖还有地址依赖会按顺执行，但是对于x = 1; y = 2;这种没有依赖关系的，仍旧会乱序发射，乱序执行。所以需要lock来进行串行执行。



### 2.2 内存屏障

### 2.3 cache与三级缓存







##  3. Threadlocal



- 弱引用的使用



![image-20220510162440256](https://gitee.com/tobewin3/picgo-home/raw/master/imgs/image-20220510162440256.png)

- key存放式一个弱引用指向Threadlocal对象，Key == this。
- value是set(obj)存放的对象。



结论，当强引用没有的时候，也就是用户代码中使用了tl.remove()的时候，会释放对象。

设计

- 为了线程独享



## 







## 4. AQS问题





## 面试题目回答

### 1. 锁

1. 锁四种状态的升级过程



![img](https://img-blog.csdnimg.cn/20200723144035268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTAwNzkxNg==,size_16,color_FFFFFF,t_70)



![image-20220401125744148](D:\blgs\source\imgs\image-20220401125744148.png)

- 无锁
  无锁：MarkWord标志位01，没有线程执行同步方法/代码块时的状态

- 偏向锁
  我们认为很多时候遇不到多线程高并发的情况，我们就偏向于第一个进来的线程。具体的实现过程：
  当一个线程访问同步块并获取锁时，会在对象头和栈帧的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需测试Mark Word里线程ID是否为当前线程。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要判断偏向锁的标识。如果标识被设置为0（表示当前是无锁状态），则使用CAS竞争锁；如果标识设置成1（表示当前是偏向锁状态），则尝试使用CAS将对象头的偏向锁指向当前线程，触发偏向锁的撤销。偏向锁只有在竞争出现才会释放锁。当其他线程尝试竞争偏向锁时，程序到达全局安全点后（没有正在执行的代码），它会查看Java对象头中记录的线程是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程，撤销偏向锁，升级为轻量级锁，如果线程1不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。

- 轻量级锁（自旋锁）
  轻量级锁的获取主要由两种情况：
  ① 当关闭偏向锁功能时；
  ② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。

  一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）采用cas方式。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。

  在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，比较并设置是原子性发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。

  长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做忙等（busy-waiting）。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。

- 重量级锁
  重量级锁显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。

  重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。

  简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资



1. 内存屏障与写屏障
2. 请描述synchronized 和reentrantlock的系层实现以及重入的底层原理 
3. volatile的底层
4. DCL单例为什么要加volatile
5. 请描述synchronized 和reentrantlock的系层实现以及重入的底层原理 
6. CAS是什么,以及其中的ABA问题



### 2. 无锁





### 3. 其他(内存问题)



1. as-if-serial和happens-before于以的理解
2. 谈一下AQS，为什么AQS的底层是CSA + volatile
3. 请描述一下对象创建的过程
4. 对象的内存布局
5. Threadlocal是如何解决内存泄漏问题的？





## 参考文献

[操作系统中的线程模型](https://www.cnblogs.com/yu-xia-zheng-ye/p/13662548.html)

[ThreadLocal相关](https://zhuanlan.zhihu.com/p/102571059)

[对象的内存模型与锁的关系](https://blog.csdn.net/u013378306/article/details/106735157?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-106735157.pc_agg_new_rank&utm_term=Markword%E4%B8%AD%E5%AD%98%E6%94%BE%E9%82%A3%E4%BA%9B%E4%BF%A1%E6%81%AF&spm=1000.2123.3001.4430)
