# 线程经典的同步模型

1. 生产者消费者
2. 读者写者
3. 哲学家进餐
4. 死锁

## 死锁

1. 由于死锁的四个条件被满足，而导致线程永久处于block或者waiting状态，就是死锁。
2. 线程死锁的四个条件
    - 互斥条件
    - 不可剥夺
    - 请求与保持
    - 循环等待
    
3. 死锁的解决
    1. 预防死锁  --  打破四个必要条件之一
    2. 避免死锁  --  只分配不会导致线程死锁的资源
    3. 死锁检测和解除

# 线程提升效率的模型

1. 并行操作数组
2. 并行排序
3. 并行实现搜索
4. 并行实现动态规划

## 并行归并排序

### 实现思路
1. 划分数组，分成两部分，直到划分到小于等于给定len。
2. 对于每一个划分，开启两个线程
3. **在两个线程执行完成之后**, 进行合并。

### 结果
- 可以看到运行时间提升了4倍左右。
- 使用新电脑能提升8倍左右。
- 最大的应该是8和16倍。说明实际的数组的操作占用了大量的时间。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e50cbee95a0640cfba0440843c54753f.png)



### 总结 	
- cglib只能代理**非final**的**public**方法
- 这里为了方便统计递归版本，使用了方法中放入SortThread类的引用。
- 由于只是对这一个类进行代理，所以可以把invokeSuper改成SortThread的方法。也就把SortThrea类的引用放在代理类中。


# 线程异步执行调用

1. 窗体应用程序swing的实现。
2. 坦克大战